priority -50


snippet pr "Pragma LANGUAGE" w
{-# LANGUAGE ${1:Foo} #-}
endsnippet

snippet po "Pragma OPTIONS_GHC" w
{-# OPTIONS_GHC -${1:foo} #-}
endsnippet

snippet in "Pragma INLINE" w
{-# INLINE ${1:foo} #-}
endsnippet

snippet ib "Pragma INLINEABLE" w
{-# INLINEABLE ${1:foo} #-}
endsnippet

snippet ni "Pragma NOINLINE" w
{-# NOINLINE ${1:foo} #-}
endsnippet

snippet so "Pragma SOURCE" w
{-# SOURCE #-}
endsnippet

snippet up "Pragma UNPACK" w
{-# UNPACK #-}
endsnippet

snippet an "Pragma ANN" w
{-# ANN ${1:foo} ${2:(Just "Foo")} #-}
endsnippet

snippet at "Pragma ANN type" w
{-# ANN type ${1:Foo} ${2:(Just "Foo")} #-}
endsnippet

snippet am "Pragma ANN module" w
{-# ANN module ${1:(Just "Foo")} #-}
endsnippet

snippet sp "Pragma SPECIALISE" w
{-# SPECIALISE ${1:f} :: ${2:Int -> b -> b} #-}
endsnippet

snippet spu "Pragma SPECIALISE (unicode)" w
{-# SPECIALISE ${1:f} âˆ· ${2:Int â†’ b â†’ b} #-}
endsnippet

snippet spin "Pragma SPECIALISE INLINE" w
{-# SPECIALISE INLINE ${1:f} :: ${2:Int -> b -> b} #-}
endsnippet

snippet spinu "Pragma SPECIALISE INLINE (unicode)" w
{-# SPECIALISE INLINE ${1:f} âˆ· ${2:Int â†’ b â†’ b} #-}
endsnippet

snippet spni "Pragma SPECIALISE NOINLINE" w
{-# SPECIALISE NOINLINE ${1:f} :: ${2:Int -> b -> b} #-}
endsnippet

snippet spniu "Pragma SPECIALISE NOINLINE (unicode)" w
{-# SPECIALISE NOINLINE ${1:f} âˆ· ${2:Int â†’ b â†’ b} #-}
endsnippet

snippet ln "Pragma LINE" w
{-# LINE ${1:42} "${2:Foo.vhs}" #-}
endsnippet

snippet dp "Pragma DEPRECATED" w
{-# DEPRECATED "${1:Don't use these}" #-}
endsnippet

snippet wr "Pragma WARNING" w
{-# WARNING ${1:unsafePerformIO} "${2:This is unsafe}" #-}
endsnippet


# see for `Data.Function` from `base` package since 4.9.0.0
snippet (&) "Declare pipe version of ($) operator" w
(&) :: a -> (a -> b) -> b
(&) = flip ($)
infixl 1 &
endsnippet

snippet u(&) "Declare pipe version of ($) operator (unicode)" w
(&) âˆ· a â†’ (a â†’ b) â†’ b
(&) = flip ($)
infixl 1 &
endsnippet

snippet (.>) "Declare pipe version of (.) operator" w
(.>) :: (a -> b) -> (b -> c) -> a -> c
(.>) = flip (.)
infixl 9 .>
endsnippet

snippet "(u\(.>\)|\(âˆ˜>\))" "Declare pipe version of (âˆ˜) Unicode operator (âˆ˜>)" r
(âˆ˜>) âˆ· (a â†’ b) â†’ (b â†’ c) â†’ a â†’ c
(âˆ˜>) = flip (âˆ˜)
infixl 9 âˆ˜>
endsnippet

snippet (â€¢) "Declare pipe version of (âˆ˜) Unicode operator (â€¢)" w
(â€¢) âˆ· (a â†’ b) â†’ (b â†’ c) â†’ a â†’ c
(â€¢) = flip (âˆ˜)
infixl 9 â€¢
endsnippet

snippet (<&>) "Declare pipe version of <$> operator" w
(<&>) :: Functor f => f a -> (a -> b) -> f b
(<&>) = flip (<$>)
infixr 5 <&>
endsnippet

snippet u(<&>) "Declare pipe version of <$> operator" w
(<&>) âˆ· Functor f â‡’ f a â†’ (a â†’ b) â†’ f b
(<&>) = flip (<$>)
infixr 5 <&>
endsnippet


snippet u "undefined" w
undefined
endsnippet

snippet r "return" w
return ${1}
endsnippet

snippet p "pure" w
pure ${1}
endsnippet


snippet t "type" w
type ${1:Foo} = ${2:Bar}${3}
endsnippet

snippet d "data" w
data ${1:Foo} = ${2:Foo}${3}
endsnippet

snippet dr "data (with deriving)" w
data ${1:Foo} = ${2:Foo} deriving (${3:Show})${4}
endsnippet

snippet nt "newtype" w
newtype ${1:Foo} = ${2:Foo}${3}
endsnippet

snippet ntr "newtype" w
newtype ${1:Foo} = ${2:Foo} deriving (${3:Show})${4}
endsnippet


snippet i "import" w
import ${1}
endsnippet
snippet i' "import (aligned by `qualified` keyword)" w
import           ${1}
endsnippet
snippet pi "import (from explicit package)" w
import "${1:base}" ${2}
endsnippet

snippet iq "qualified import" w
import qualified ${1}
endsnippet
snippet piq "qualified import (from explicit package)" w
import qualified "${1:base}" ${2}
endsnippet

snippet is "qualified import as" w
import qualified ${1:Data.List} as ${2:L}
endsnippet
snippet pis "qualified import as (from explicit package)" w
import qualified "${1:base}" ${2:Data.List} as ${3:L}
endsnippet

snippet ix "explicit import" w
import ${1:Control.Monad} (${2:(>=>)})
endsnippet
snippet ix' "explicit import (aligned by `qualified` keyword)" w
import           ${1:Control.Monad} (${2:(>=>)})
endsnippet
snippet pix "explicit import (from explicit package)" w
import "${1:base}" ${2:Control.Monad} (${3:(>=>)})
endsnippet


snippet m "module" w
module ${1:Main} where
endsnippet

snippet m- "module prefix" w
module ${1}
endsnippet

snippet mx "module with explicit export" w
module ${1:Main} (${2:main}) where
endsnippet

snippet mm "module with multiline explicit export" w
module ${1:Foo}
	( ${2:Bar}
	) where
endsnippet

snippet mm' "module with multiline explicit export (aligned)" w
module ${1:Foo}
     ( ${2:Bar}
     ) where
endsnippet


# wrapping name of the function to ${} doesn't make sense
# becase we need to edit function name two times, let's
# do it later.
snippet f "declare a function" w
f :: ${1:Foo}
f = ${2:undefined}
endsnippet

snippet fu "declare a function (unicode)" w
f âˆ· ${1:Foo}
f = ${2:undefined}
endsnippet

snippet la "declare a lambda" i
\\${1:x} -> ${2:undefined}
endsnippet

snippet lu "declare a lambda (unicode)" i
\\${1:x} â†’ ${2:undefined}
endsnippet

snippet lb "declare a lambda wrapped to brackets" w
(\\${1:x} -> ${2:undefined})
endsnippet

snippet lbu "declare a lambda wrapped to brackets (unicode)" w
(\\${1:x} â†’ ${2:undefined})
endsnippet


snippet main "main monad" w
main :: IO ()
main = ${1:undefined}
endsnippet

snippet mainu "main monad (unicode)" w
main âˆ· IO ()
main = ${1:undefined}
endsnippet


snippet qq "quasi-quote" w
[${1:foo}|${2:bar}|]${3}
endsnippet

snippet qm "qm interpolated string quasi-quote" w
[qm| ${1:foo} |]${2}
endsnippet

snippet qn "qn multiline string quasi-quote" w
[qn| ${1:foo} |]${2}
endsnippet

snippet qmb "qmb interpolated string quasi-quote" w
[qmb| ${1:foo} |]${2}
endsnippet

snippet qnb "qnb multiline string quasi-quote" w
[qnb| ${1:foo} |]${2}
endsnippet

snippet qms "qms interpolated string quasi-quote" w
[qms| ${1:foo} |]${2}
endsnippet

snippet qns "qns multiline string quasi-quote" w
[qns| ${1:foo} |]${2}
endsnippet



# UnicodeSyntax

# Personal favorites
# âˆ€ Â¬ âˆ§ âˆ¨ â‰¡ â‰  â‰¤ â‰¥ âˆ˜ âˆ˜> âˆˆ âˆ‰ âˆŒ âˆ‹


# From the UnicodeSyntax extension
snippet :: "Unicode :: = âˆ·" i
âˆ· ${1}
endsnippet
snippet "(^|[^:]):" "Unicode : = âˆ·" r
`!p snip.rv = match.group(1)`âˆ· ${1}
endsnippet
snippet => "Unicode => = â‡’" w
â‡’ ${1}
endsnippet
snippet forall "Unicode forall = âˆ€" w
âˆ€ ${1}
endsnippet
snippet A "Unicode A = âˆ€" w
âˆ€ ${1}
endsnippet
snippet -> "Unicode -> = â†’" w
â†’ ${1}
endsnippet
snippet > "Unicode > = â†’" w
â†’ ${1}
endsnippet
snippet <- "Unicode <- = â†" w
â† ${1}
endsnippet
snippet < "Unicode < = â†" w
â† ${1}
endsnippet
snippet >- "Unicode >- = â¤š" w
â¤š ${1}
endsnippet
snippet -< "Unicode -< = â¤™" w
â¤™ ${1}
endsnippet
snippet -<< "Unicode -<< = â¤›" w
â¤› ${1}
endsnippet
snippet >>- "Unicode >>- = â¤œ" w
â¤œ ${1}
endsnippet
snippet *t "Unicode * = â˜…" w
â˜… ${1}
endsnippet


# Own unicode operators
snippet <> "Unicode <> = â‹„ (diamond operator)" i
â‹„ ${1}
endsnippet


# From the Prelude.Unicode module

# Values
snippet not "Unicode not = (Â¬)" w
Â¬
endsnippet
snippet && "Unicode (&&) = (âˆ§)" w
âˆ§ ${1}
endsnippet
snippet & "Unicode & = âˆ§" w
âˆ§ ${1}
endsnippet
snippet a "Unicode a = âˆ§" w
âˆ§ ${1}
endsnippet
snippet || "Unicode (||) = (âˆ¨)" w
âˆ¨ ${1}
endsnippet
snippet | "Unicode | = âˆ¨" w
âˆ¨ ${1}
endsnippet
snippet o "Unicode o = âˆ¨" w
âˆ¨ ${1}
endsnippet
snippet "(^|[^/])==" "Unicode (==) = (â‰¡)" r
`!p snip.rv = match.group(1)`â‰¡ ${1}
endsnippet
snippet "(^|[^=/><])=" "Unicode = to â‰¡" r
`!p snip.rv = match.group(1)`â‰¡ ${1}
endsnippet
snippet /= "Unicode (/=) = (â‰ )" i
â‰  ${1}
endsnippet
snippet /â‰¡ "Unicode (/=) = (â‰¢)" i
â‰¢
endsnippet
snippet /== "Unicode (/=) = (â‰¢)" i
â‰¢ ${1}
endsnippet
snippet <= "Unicode <= = â‰¤" i
â‰¤ ${1}
endsnippet
snippet /> "Unicode <= = â‰¯" i
â‰¯ ${1}
endsnippet
snippet >= "Unicode >= = â‰¥" i
â‰¥ ${1}
endsnippet
snippet /< "Unicode >= = â‰®" i
â‰® ${1}
endsnippet
snippet PI "Unicode pi = Ï€" w
Ï€ ${1}
endsnippet
snippet / "Unicode (/) = (Ã·)" i
Ã· ${1}
endsnippet
snippet * "Unicode (*) = (â‹…)" i
â‹… ${1}
endsnippet
snippet . "Unicode (.) = (âˆ˜)" i
âˆ˜ ${1}
endsnippet
# my own
snippet .> "Unicode (.>) = (âˆ˜>)" w
âˆ˜> ${1}
endsnippet
snippet ++ "Unicode (++) = (â§º)" i
â§º ${1}
endsnippet
snippet "(^|[^\+])\+" "Unicode + = â§º" r
`!p snip.rv = match.group(1)`â§º ${1}
endsnippet
snippet elem "Unicode elem = (âˆˆ)" w
âˆˆ ${1}
endsnippet
snippet "(^|[^/])E" "Unicode E = (âˆˆ)" r
`!p snip.rv = match.group(1)`âˆˆ ${1}
endsnippet
snippet notElem "Unicode notElem = (âˆ‰)" w
âˆ‰ ${1}
endsnippet
snippet /E "Unicode /E = (âˆ‰)" w
âˆ‰ ${1}
endsnippet
snippet E/ "Unicode E/ = (âˆ‰)" w
âˆ‰ ${1}
endsnippet
snippet undefined "Unicode undefined = (âŠ¥)" w
âŠ¥
endsnippet

# Types
snippet Integer "Unicode Integer = â„¤" w
â„¤ ${1}
endsnippet
snippet Z "Unicode Z = â„¤" w
â„¤ ${1}
endsnippet
snippet Rational "Unicode Rational = â„š" w
â„š ${1}
endsnippet
snippet Q "Unicode Q = â„š" w
â„š ${1}
endsnippet
snippet Bool "Unicode Bool = ğ”¹" w
ğ”¹ ${1}
endsnippet
snippet B "Unicode B = ğ”¹" w
ğ”¹ ${1}
endsnippet


# From the Control.Applicative.Unicode module
snippet <*> "Unicode (<*>) = (âŠ›)" w
âŠ›
endsnippet
snippet empty "Unicode empty = (âˆ…)" w
âˆ…
endsnippet


# From the Control.Arrow.Unicode module
snippet >>> "Unicode (>>>) = (â‹™)" w
â‹™
endsnippet
snippet <<< "Unicode (<<<) = (â‹˜)" w
â‹˜
endsnippet
snippet *** "Unicode (***) = (â‚)" w
â‚
endsnippet
snippet +++ "Unicode (+++) = (â§»)" w
â§»
endsnippet
snippet ||| "Unicode (|||) = (â«´)" w
â«´
endsnippet


# From the Control.Category.Unicode module
# (.) = (âˆ˜)
# (>>>) = (â‹™)
# (<<<) = (â‹˜)


# From the Control.Monad.Unicode module
snippet >>= "Unicode (>>=) = (â‰«=)" w
â‰«=
endsnippet
snippet >> "Unicode (>>) = (â‰«)" w
â‰«
endsnippet
snippet =<< "Unicode (=<<) = (=â‰ª)" w
=â‰ª
endsnippet


# From the Data.Bool.Unicode module
# (&&) = (âˆ§)
# (||) = (âˆ¨)
# not = (Â¬)


# From the Data.Eq.Unicode module
# (==) = (â‰¡)
# (/=) = (â‰ ) = (â‰¢)


# From the Data.Foldable.Unicode module
# elem = (âˆˆ)
# flip elem = (âˆ‹)
snippet âˆˆ "Unicode flip elem = (âˆ‹)" i
âˆ‹
endsnippet
snippet "(^|[^\/])3" "Unicode 3 = (âˆ‹)" r
`!p snip.rv = match.group(1)`âˆ‹ ${1}
endsnippet
# notElem = (âˆ‰)
# flip notElem = (âˆŒ)
snippet âˆ‰ "Unicode flip notElem = (âˆŒ)" i
âˆŒ
endsnippet
snippet /3 "Unicode /3 = (âˆŒ)" i
âˆŒ ${1}
endsnippet
snippet 3/ "Unicode 3/ = (âˆŒ)" i
âˆŒ ${1}
endsnippet


# From the Data.Function.Unicode module
# (.) = (âˆ˜)


# From the Data.List.Unicode module
# (++) = (â§º)
# elem = (âˆˆ)
# flip elem = (âˆ‹)
# notElem = (âˆ‰)
# flip notElem = (âˆŒ)
snippet union "Unicode union = (âˆª)" w
âˆª
endsnippet
snippet \\ "Unicode (\\) = (âˆ–)" w
âˆ–
endsnippet
# \x y -> union (x \\ y) (y \\ x) = (âˆ†)
snippet intersect "Unicode intersect = (âˆ©)" w
âˆ©
endsnippet


# From the Data.Monoid.Unicode module
snippet mempty "Unicode mempty = (âˆ…)" w
âˆ…
endsnippet
snippet mappend "Unicode mappend = (âŠ•)" w
âŠ•
endsnippet


# From the Data.Ord.Unicode module
# <= = â‰¤ = â‰¯
# >= = â‰¥ = â‰®



# From the containers-unicode-symbols package


# From the Data.Sequence.Unicode module
# empty = (âˆ…)
snippet <| "Unicode (<|) = (âŠ²)" w
âŠ²
endsnippet
snippet |> "Unicode (|>) = (âŠ³)" w
âŠ³
endsnippet
snippet >< "Unicode (><) = (â‹ˆ)" w
â‹ˆ
endsnippet


# From the Data.Set.Unicode module
# member = (âˆˆ)
# flip member = (âˆ‹)
# notMember = (âˆ‰)
# flip notMember = (âˆŒ)
# empty = (âˆ…)
# union = (âˆª)
snippet difference "Unicode difference = (âˆ–)" w
âˆ–
endsnippet
# \x y -> union (difference x y) (difference y x) = (âˆ†)
snippet /\ "Unicode `union (difference x y) (difference y x)` = (âˆ†)" w
âˆ†
endsnippet
# intersection = (âˆ©)
snippet isSubsetOf "Unicode isSubsetOf = (âŠ†)" w
âŠ†
endsnippet
snippet âŠ† "Unicode flip isSubsetOf = (âŠ‡)" w
âŠ‡
endsnippet
# \x y -> (x /= y) && not (isProperSubsetOf x y) = (âŠˆ)
# \x y -> (x /= y) && not (isProperSubsetOf y x) = (âŠ‰)
# isProperSubsetOf = (âŠ‚)
# flip isProperSubsetOf = (âŠƒ)
# \x y -> not (isProperSubsetOf x y) = (âŠ„)
# \x y -> not (isProperSubsetOf y x) = (âŠ…)


# From the Data.Map.Lazy.Unicode module (reexported by the Data.Map.Unicode module)
# member = (âˆˆ)
# flip member = (âˆ‹)
# notMember = (âˆ‰)
# flip notMember = (âˆŒ)
# empty = (âˆ…)
# union = (âˆª)
# difference = (âˆ–)
# \x y -> union (difference x y) (difference y x) = (âˆ†)
# intersection = (âˆ©)


# From the Data.Map.Strict.Unicode module
# member = (âˆˆ)
# flip member = (âˆ‹)
# notMember = (âˆ‰)
# flip notMember = (âˆŒ)
# empty = (âˆ…)
# union = (âˆª)
# difference = (âˆ–)
# \x y -> union (difference x y) (difference y x) = (âˆ†)
# intersection = (âˆ©)


# From the Data.IntSet.Unicode module
# member = (âˆˆ)
# flip member = (âˆ‹)
# notMember = (âˆ‰)
# flip notMember = (âˆŒ)
# empty = (âˆ…)
# union = (âˆª)
# difference = (âˆ–)
# \x y -> union (difference x y) (difference y x) = (âˆ†)
# intersection = (âˆ©)
# isSubsetOf = (âŠ†)
# flip isSubsetOf = (âŠ‡)
# \x y -> (x /= y) && not (isProperSubsetOf x y) = (âŠˆ)
# \x y -> (x /= y) && not (isProperSubsetOf y x) = (âŠ‰)
# isProperSubsetOf = (âŠ‚)
# flip isProperSubsetOf = (âŠƒ)
# \x y -> not (isProperSubsetOf x y) = (âŠ„)
# \x y -> not (isProperSubsetOf y x) = (âŠ…)


# From the Data.IntMap.Lazy.Unicode module (reexported by the Data.IntMap.Unicode module)
# member = (âˆˆ)
# flip member = (âˆ‹)
# notMember = (âˆ‰)
# flip notMember = (âˆŒ)
# empty = (âˆ…)
# union = (âˆª)
# difference = (âˆ–)
# \x y -> union (difference x y) (difference y x) = (âˆ†)
# intersection = (âˆ©)


# From the Data.IntMap.Strict.Unicode module
# member = (âˆˆ)
# flip member = (âˆ‹)
# notMember = (âˆ‰)
# flip notMember = (âˆŒ)
# empty = (âˆ…)
# union = (âˆª)
# difference = (âˆ–)
# \x y -> union (difference x y) (difference y x) = (âˆ†)
# intersection = (âˆ©)
